---
title: C++ 基础核心知识点总结
date: 2021-03-09 14:31  
tags: [code, c++]
---

# C++ 基础核心知识点总结

本文系统梳理 C++ 基础语法、面向对象编程（OOP）核心特性及关键概念，涵盖内存管理、指针、多态、模板等高频考点，适合用于学习回顾或面试备考。


## 一、C++ 基础语法与核心概念

### 1. 左值与右值引用
#### 1.1 左右值定义
- **左值（Lvalue）**：可出现在赋值符号`=`左右两侧的值，代表一块可被访问的内存地址（如变量、数组元素、对象成员）。  
  示例：`int a = 5;` 中，`a`是左值，`5`是右值。
- **右值（Rvalue）**：仅能出现在赋值符号`=`右侧的值，通常是临时变量、字面量或表达式结果（无持久内存地址）。  
  示例：`a = b + 3;` 中，`b + 3`的结果是右值。

#### 1.2 右值引用（C++11 新增）
- 定义：用`&&`声明，专门绑定右值（临时对象），延长其生命周期，避免不必要的拷贝。  
  示例：`int&& r = 10;`（`r`是右值引用，绑定临时变量`10`）。
- 核心用途：实现**移动语义**，解决深拷贝的性能问题（如`std::string`、`std::vector`的移动构造）。

#### 1.3 邪道定义的局限性
“能被取地址的是左值，反之是右值”这一说法不严谨，因为：  
- 无法对**位域的某一位**取地址（如`struct S { int a : 4; }; S s; &s.a`非法）；  
- 无法对**未命名临时对象的成员**直接取地址（如`std::string("abc").c_str()`虽能获取字符地址，但对象本身是右值）。


### 2. 移动语义与完美转发
#### 2.1 移动语义
- **问题背景**：传统深拷贝（如`std::vector`拷贝）需重新分配内存并复制数据，效率低；若源对象是临时变量（右值），拷贝后即被销毁，存在冗余。  
- **解决方案**：移动语义通过“浅拷贝+源对象置空”实现资源转移，避免内存重复分配。  
  示例：`std::vector<int> v1 = {1,2,3}; std::vector<int> v2 = std::move(v1);`（`v1`的内存资源转移给`v2`，`v1`变为空）。
- **关键函数**：`std::move()`本质是`static_cast<T&&>()`的封装，仅将左值“强制转换”为右值引用，不触发实际移动，移动操作由**移动构造函数**或**移动赋值运算符**完成。

#### 2.2 完美转发
- **问题背景**：函数模板传递参数时，若参数是右值，可能因拷贝或类型转换变为左值，导致无法正确匹配移动语义。  
- **解决方案**：用`std::forward<T>()`保留参数的左右值属性，确保参数以“原始类型”传递给目标函数。  
  典型场景：模板函数转发参数至其他函数（如`std::make_unique`、`std::thread`）。

**代码示例：完美转发的必要性**
```cpp
#include <iostream>
using namespace std;

void PrintT(int& t) { cout << "lvalue: " << t << endl; }
void PrintT(int&& t) { cout << "rvalue: " << t << endl; }

// 不使用完美转发：参数v会被转为左值
template <typename T>
void Test(T v) {
    PrintT(v); // 始终调用左值版本
}

// 使用完美转发：保留v的左右值属性
template <typename T>
void TestForward(T&& v) {
    PrintT(forward<T>(v)); // 左值传左值，右值传右值
}

int main() {
    int a = 5;
    Test(a);        // 输出 "lvalue: 5"
    Test(10);       // 输出 "lvalue: 10"（右值被转为左值）
    TestForward(a); // 输出 "lvalue: 5"
    TestForward(10);// 输出 "rvalue: 10"（完美转发右值）
    return 0;
}
```


### 3. 智能指针（Smart Pointer）
智能指针是封装原始指针的类模板，自动管理内存（超出作用域时调用`delete`），避免内存泄漏和野指针问题。C++11 提供三种核心智能指针：

| 类型          | 核心特性                                                                 | 适用场景                     |
|---------------|--------------------------------------------------------------------------|------------------------------|
| `std::shared_ptr` | 共享所有权，内部维护**引用计数**（拷贝时计数+1，析构时计数-1，计数为0时释放内存）。 | 多个对象共享同一资源（如多线程共享数据）。 |
| `std::unique_ptr` | 独占所有权，禁止拷贝（仅支持移动），无引用计数开销，效率最高。                 | 单一对象独占资源（如动态数组、局部动态对象）。 |
| `std::weak_ptr`   | 弱引用，不增加`shared_ptr`的引用计数，可解决`shared_ptr`的**循环引用**问题。   | 观测`shared_ptr`管理的资源，避免循环引用。 |

#### 关键注意事项
- `shared_ptr`避免循环引用：若两个`shared_ptr`互相指向对方，引用计数永远无法归零，导致内存泄漏（需用`weak_ptr`打破循环）。  
- `unique_ptr`的转移：通过`std::move()`转移所有权，转移后原`unique_ptr`变为空（不可再访问）。  
- `shared_ptr`线程安全：引用计数的增减是原子操作，但对象的读写需额外加锁（如`std::mutex`）。

**代码示例：shared_ptr 循环引用问题**
```cpp
#include <memory>
using namespace std;

class B; // 前向声明
class A {
public:
    shared_ptr<B> b_ptr; // A持有B的shared_ptr
    ~A() { cout << "A destroyed" << endl; }
};
class B {
public:
    shared_ptr<A> a_ptr; // B持有A的shared_ptr（循环引用）
    ~B() { cout << "B destroyed" << endl; }
};

int main() {
    shared_ptr<A> a = make_shared<A>();
    shared_ptr<B> b = make_shared<B>();
    a->b_ptr = b; // A指向B
    b->a_ptr = a; // B指向A（循环引用）
    // 退出作用域时，a和b的引用计数均为2，析构后变为1，内存泄漏
    return 0;
}
// 修复方案：将B的a_ptr改为weak_ptr<B>，不增加引用计数
```


### 4. C++ 与 C 语言的内存分配区别
C++ 继承 C 的内存管理逻辑，但通过`new/delete`增强了类型安全性和对象初始化能力，核心区别如下：

| 对比维度         | C++ `new/delete`                          | C `malloc/free`                          |
|------------------|-------------------------------------------|------------------------------------------|
| **操作本质**     | 运算符（可重载）                          | 标准库函数                               |
| **内存位置**     | 自由存储区（通常与堆重叠，但由编译器决定） | 堆（Heap）                               |
| **类型检查**     | 按类型分配，返回对应类型指针（无需强转）   | 按字节分配，返回`void*`（需显式强转）    |
| **对象初始化**   | 调用构造函数（如`new int(10)`初始化值为10）| 仅分配内存，不初始化（值为随机）         |
| **对象销毁**     | 调用析构函数（释放资源，如动态成员）       | 仅释放内存，不调用析构（可能内存泄漏）   |
| **错误处理**     | 内存分配失败抛出`std::bad_alloc`异常      | 返回`NULL`指针                           |
| **数组支持**     | `new[]`分配数组，`delete[]`释放（需匹配）  | 需手动计算字节数（如`malloc(5*sizeof(int))`） |

#### 底层实现原理
- **`malloc`**：  
  1. 小内存（<128KB）：调用`brk()`调整堆顶指针（`sbrk`），分配连续内存；  
  2. 大内存（≥128KB）：调用`mmap()`在文件映射区分配独立内存块；  
  3. 内存池管理：采用“隐式链表”维护空闲块，减少系统调用开销，避免内存碎片。

- **`new`**：  
  1. 调用`operator new`分配内存（底层可调用`malloc`或自定义逻辑）；  
  2. 调用对象的构造函数（初始化成员、分配资源）；  
  3. 返回对象指针；  
  4. 释放时，`delete`先调用析构函数，再调用`operator delete`释放内存。


### 5. `struct` 与 `class` 的区别
C++ 中`struct`是`class`的“简化版”，核心区别在于**默认访问权限**和**默认继承方式**，其余功能（如成员函数、继承、多态）完全一致：

| 特性               | `struct`                                  | `class`                                  |
|--------------------|-------------------------------------------|------------------------------------------|
| **默认访问权限**   | 成员默认`public`（外部可直接访问）         | 成员默认`private`（仅内部/友元可访问）   |
| **默认继承方式**   | 默认公有继承（`public`）                   | 默认私有继承（`private`）                 |
| **模板参数支持**   | 不能作为模板参数（如`template <struct T>`非法） | 可作为模板参数（如`template <class T>`合法） |
| **使用场景**       | 通常用于存储数据结构（如`struct Point { int x; int y; }`） | 用于封装对象（含属性和方法，强调OOP）     |



### 6. 异常处理机制
C++ 提供`try-catch-throw`异常处理模型，用于捕获和处理运行时错误（如内存分配失败、数组越界），替代 C 语言的`abort()`/`exit()`（强制终止程序）。

#### 核心语法
```cpp
try {
    // 可能抛出异常的代码
    if (/* 错误条件 */) {
        throw 异常值; // 抛出异常（类型可自定义，如int、string、自定义类）
    }
} catch (异常类型1& e) {
    // 处理类型1的异常
} catch (异常类型2& e) {
    // 处理类型2的异常
} catch (...) {
    // 捕获所有未匹配的异常（兜底处理）
}
```

#### 关键特性
- **异常传播**：若`try`块中抛出的异常未被当前`catch`捕获，会向上传播至调用栈，直至找到匹配的`catch`或程序终止。  
- **标准异常**：C++ 标准库提供异常类体系（如`std::bad_alloc`、`std::out_of_range`），可直接抛出或继承扩展。  
- **资源安全**：异常抛出时，局部对象会自动调用析构函数（“栈展开”机制），避免资源泄漏（推荐用 RAII 模式管理资源，如智能指针）。


### 7. 深拷贝与浅拷贝
拷贝是对象复制的过程，核心区别在于**是否重新分配资源**（如动态内存、文件句柄）：

| 类型       | 实现方式                                                                 | 优点                     | 缺点                                 |
|------------|--------------------------------------------------------------------------|--------------------------|--------------------------------------|
| **浅拷贝** | 位拷贝（默认拷贝构造函数/赋值运算符），仅复制成员值，不复制资源。         | 效率高（无额外内存分配） | 多个对象共享资源，析构时可能重复释放（崩溃）或内存泄漏。 |
| **深拷贝** | 显式定义拷贝构造函数/赋值运算符，为新对象重新分配资源并复制内容。         | 资源独立（无共享问题）   | 效率低（需分配内存+复制